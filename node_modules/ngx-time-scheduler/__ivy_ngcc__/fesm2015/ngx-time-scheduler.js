import { __decorate, __metadata } from 'tslib';
import { ɵɵdefineInjectable, Injectable, ChangeDetectorRef, ViewChild, ElementRef, Input, Component, NgModule } from '@angular/core';
import { Subject, Subscription } from 'rxjs';
import * as moment_ from 'moment';
import { CommonModule } from '@angular/common';
import { DragDropModule } from '@angular/cdk/drag-drop';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/cdk/drag-drop';

const _c0 = ["sectionTd"];
const _c1 = ["items", "", "periods", "", "sections", ""];
function NgxTimeSchedulerComponent_button_3_Template(rf, ctx) { if (rf & 1) {
    const _r10 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 17);
    ɵngcc0.ɵɵlistener("click", function NgxTimeSchedulerComponent_button_3_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r10); const period_r8 = ctx.$implicit; const ctx_r9 = ɵngcc0.ɵɵnextContext(); return ctx_r9.changePeriod(period_r8); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const period_r8 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("ngClass", period_r8.classes)("title", period_r8.tooltip ? period_r8.tooltip : "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", period_r8.name, " ");
} }
function NgxTimeSchedulerComponent_button_5_Template(rf, ctx) { if (rf & 1) {
    const _r12 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 7);
    ɵngcc0.ɵɵlistener("click", function NgxTimeSchedulerComponent_button_5_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r12); const ctx_r11 = ɵngcc0.ɵɵnextContext(); return ctx_r11.showGotoModal = !ctx_r11.showGotoModal; });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r1.text.GotoButton);
} }
function NgxTimeSchedulerComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    const _r14 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 18);
    ɵngcc0.ɵɵelementStart(1, "label");
    ɵngcc0.ɵɵelementStart(2, "input", 19);
    ɵngcc0.ɵɵlistener("change", function NgxTimeSchedulerComponent_div_6_Template_input_change_2_listener($event) { ɵngcc0.ɵɵrestoreView(_r14); const ctx_r13 = ɵngcc0.ɵɵnextContext(); return ctx_r13.gotoDate($event.target.value); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} }
function NgxTimeSchedulerComponent_button_7_Template(rf, ctx) { if (rf & 1) {
    const _r16 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "button", 7);
    ɵngcc0.ɵɵlistener("click", function NgxTimeSchedulerComponent_button_7_Template_button_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r16); const ctx_r15 = ɵngcc0.ɵɵnextContext(); return ctx_r15.gotoToday(); });
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r3 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(ctx_r3.text.TodayButton);
} }
function NgxTimeSchedulerComponent_tr_16_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 22);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r19 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("rowSpan", ctx_r19.periods.length);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r19.text.SectionTitle, " ");
} }
function NgxTimeSchedulerComponent_tr_16_td_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td", 23);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const dateTime_r21 = ctx.$implicit;
    ɵngcc0.ɵɵproperty("colSpan", dateTime_r21.colspan)("title", dateTime_r21.tooltip ? dateTime_r21.tooltip : "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", dateTime_r21.name, " ");
} }
function NgxTimeSchedulerComponent_tr_16_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, NgxTimeSchedulerComponent_tr_16_td_1_Template, 2, 2, "td", 20);
    ɵngcc0.ɵɵtemplate(2, NgxTimeSchedulerComponent_tr_16_td_2_Template, 2, 3, "td", 21);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const timeFrameHeader_r17 = ctx.$implicit;
    const i_r18 = ctx.index;
    const ctx_r4 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", i_r18 === 0);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", timeFrameHeader_r17.headerDetails)("ngForTrackBy", ctx_r4.trackByFn);
} }
function NgxTimeSchedulerComponent_tr_19_td_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "td");
} }
function NgxTimeSchedulerComponent_tr_19_Template(rf, ctx) { if (rf & 1) {
    const _r27 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵelementStart(1, "td", 24, 25);
    ɵngcc0.ɵɵlistener("click", function NgxTimeSchedulerComponent_tr_19_Template_td_click_1_listener() { ɵngcc0.ɵɵrestoreView(_r27); const sectionItem_r22 = ctx.$implicit; const ctx_r26 = ɵngcc0.ɵɵnextContext(); return ctx_r26.events.SectionClickEvent ? ctx_r26.events.SectionClickEvent(sectionItem_r22.section) : false; })("contextmenu", function NgxTimeSchedulerComponent_tr_19_Template_td_contextmenu_1_listener($event) { ɵngcc0.ɵɵrestoreView(_r27); const sectionItem_r22 = ctx.$implicit; const ctx_r28 = ɵngcc0.ɵɵnextContext(); return ctx_r28.events.SectionContextMenuEvent ? ctx_r28.events.SectionContextMenuEvent(sectionItem_r22.section, $event) : false; });
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, NgxTimeSchedulerComponent_tr_19_td_4_Template, 1, 0, "td", 11);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const sectionItem_r22 = ctx.$implicit;
    const ctx_r5 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("height", sectionItem_r22.minRowHeight + "px");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("cursor", ctx_r5.events.SectionClickEvent ? "pointer" : "");
    ɵngcc0.ɵɵproperty("title", sectionItem_r22.section.tooltip ? sectionItem_r22.section.tooltip : "");
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵtextInterpolate1(" ", sectionItem_r22.section.name, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", ctx_r5.header[ctx_r5.header.length - 1].headerDetails)("ngForTrackBy", ctx_r5.trackByFn);
} }
function NgxTimeSchedulerComponent_div_21_div_1_div_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 33);
} if (rf & 2) {
    const itemMeta_r31 = ɵngcc0.ɵɵnextContext().$implicit;
    const ctx_r32 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("height", ctx_r32.minRowHeight - 6 + "px")("left", itemMeta_r31.cssLeft + "%")("width", "calc(" + itemMeta_r31.cssWidth + "% - 6px)");
} }
function NgxTimeSchedulerComponent_div_21_div_1_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 34);
} }
function NgxTimeSchedulerComponent_div_21_div_1_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 35);
} }
function NgxTimeSchedulerComponent_div_21_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r37 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 28);
    ɵngcc0.ɵɵlistener("click", function NgxTimeSchedulerComponent_div_21_div_1_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r37); const itemMeta_r31 = ctx.$implicit; const ctx_r36 = ɵngcc0.ɵɵnextContext(2); return ctx_r36.events.ItemClicked ? ctx_r36.events.ItemClicked(itemMeta_r31.item) : false; })("contextmenu", function NgxTimeSchedulerComponent_div_21_div_1_Template_div_contextmenu_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r37); const itemMeta_r31 = ctx.$implicit; const ctx_r38 = ɵngcc0.ɵɵnextContext(2); return ctx_r38.events.ItemContextMenu ? ctx_r38.events.ItemContextMenu(itemMeta_r31.item, $event) : false; });
    ɵngcc0.ɵɵtemplate(1, NgxTimeSchedulerComponent_div_21_div_1_div_1_Template, 1, 6, "div", 29);
    ɵngcc0.ɵɵtemplate(2, NgxTimeSchedulerComponent_div_21_div_1_div_2_Template, 1, 0, "div", 30);
    ɵngcc0.ɵɵelementStart(3, "div", 31);
    ɵngcc0.ɵɵtext(4);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(5, NgxTimeSchedulerComponent_div_21_div_1_div_5_Template, 1, 0, "div", 32);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const itemMeta_r31 = ctx.$implicit;
    const ctx_r30 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵstyleProp("height", ctx_r30.minRowHeight + "px")("top", itemMeta_r31.cssTop + "px")("left", itemMeta_r31.cssLeft + "%")("width", itemMeta_r31.cssWidth + "%");
    ɵngcc0.ɵɵproperty("cdkDragData", itemMeta_r31.item)("cdkDragDisabled", !ctx_r30.allowDragging)("ngClass", itemMeta_r31.item.classes);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", itemMeta_r31.isStart);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("title", itemMeta_r31.item.tooltip ? itemMeta_r31.item.tooltip : "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", itemMeta_r31.item.name, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", itemMeta_r31.isEnd);
} }
function NgxTimeSchedulerComponent_div_21_Template(rf, ctx) { if (rf & 1) {
    const _r40 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 26);
    ɵngcc0.ɵɵlistener("cdkDropListDropped", function NgxTimeSchedulerComponent_div_21_Template_div_cdkDropListDropped_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r40); const ctx_r39 = ɵngcc0.ɵɵnextContext(); return ctx_r39.drop($event); });
    ɵngcc0.ɵɵtemplate(1, NgxTimeSchedulerComponent_div_21_div_1_Template, 6, 15, "div", 27);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const sectionItem_r29 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("height", sectionItem_r29.minRowHeight + "px");
    ɵngcc0.ɵɵproperty("cdkDropListData", sectionItem_r29.section);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", sectionItem_r29.itemMetas);
} }
function NgxTimeSchedulerComponent_div_22_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div", 36);
} if (rf & 2) {
    const ctx_r7 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵstyleProp("visibility", ctx_r7.currentTimeVisibility)("left", ctx_r7.currentTimeIndicatorPosition);
    ɵngcc0.ɵɵproperty("title", ctx_r7.currentTimeTitle);
} }
let NgxTimeSchedulerService = class NgxTimeSchedulerService {
    constructor() {
        this.item = new Subject();
        this.itemAdd = new Subject();
        this.itemId = new Subject();
        this.sectionAdd = new Subject();
        this.section = new Subject();
        this.sectionId = new Subject();
        this.refreshView = new Subject();
    }
    itemPush(item) {
        this.itemAdd.next(item);
    }
    itemPop() {
        this.item.next();
    }
    itemRemove(id) {
        this.itemId.next(id);
    }
    sectionPush(section) {
        this.sectionAdd.next(section);
    }
    sectionPop() {
        this.section.next();
    }
    sectionRemove(id) {
        this.sectionId.next(id);
    }
    refresh() {
        this.refreshView.next();
    }
};
NgxTimeSchedulerService.ɵfac = function NgxTimeSchedulerService_Factory(t) { return new (t || NgxTimeSchedulerService)(); };
NgxTimeSchedulerService.ɵprov = ɵɵdefineInjectable({ factory: function NgxTimeSchedulerService_Factory() { return new NgxTimeSchedulerService(); }, token: NgxTimeSchedulerService, providedIn: "root" });
NgxTimeSchedulerService = __decorate([ __metadata("design:paramtypes", [])
], NgxTimeSchedulerService);

class Period {
}
class Item {
}
class Section {
}
class Text {
    constructor() {
        this.NextButton = 'Next';
        this.PrevButton = 'Prev';
        this.TodayButton = 'Today';
        this.GotoButton = 'Go to';
        this.SectionTitle = 'Section';
    }
}
class Events {
}
class SectionItem {
    constructor() {
        this.itemMetas = new Array();
    }
}
class ItemMeta {
    constructor() {
        this.cssTop = 0;
        this.cssLeft = 0;
        this.cssWidth = 0;
    }
}
class Header {
    constructor() {
        this.headerDetails = new Array();
    }
}
class HeaderDetails {
}

const moment = moment_;
let NgxTimeSchedulerComponent = class NgxTimeSchedulerComponent {
    constructor(changeDetector, service) {
        this.changeDetector = changeDetector;
        this.service = service;
        this.currentTimeFormat = 'DD-MMM-YYYY HH:mm';
        this.showCurrentTime = true;
        this.showGoto = true;
        this.showToday = true;
        this.allowDragging = false;
        // @Input() allowResizing = false;
        this.locale = '';
        this.showBusinessDayOnly = false;
        this.headerFormat = 'Do MMM YYYY';
        this.minRowHeight = 40;
        this.maxHeight = null;
        this.text = new Text();
        this.events = new Events();
        this.start = moment().startOf('day');
        this.end = moment().endOf('day');
        this.showGotoModal = false;
        this.currentTimeVisibility = 'visible';
        this.ShowCurrentTimeHandle = null;
        this.SectionLeftMeasure = '0';
        this.currentPeriodMinuteDiff = 0;
        this.subscription = new Subscription();
        this.showCurrentTimeIndicator = () => {
            if (this.ShowCurrentTimeHandle) {
                clearTimeout(this.ShowCurrentTimeHandle);
            }
            const currentTime = moment();
            if (currentTime >= this.start && currentTime <= this.end) {
                this.currentTimeVisibility = 'visible';
                this.currentTimeIndicatorPosition = ((Math.abs(this.start.diff(currentTime, 'minutes')) / this.currentPeriodMinuteDiff) * 100) + '%';
                this.currentTimeTitle = currentTime.format(this.currentTimeFormat);
            }
            else {
                this.currentTimeVisibility = 'hidden';
            }
            this.ShowCurrentTimeHandle = setTimeout(this.showCurrentTimeIndicator, 30000);
        };
        moment.locale(this.locale);
    }
    set SectionTd(elementRef) {
        this.SectionLeftMeasure = elementRef.nativeElement.clientWidth + 'px';
        this.changeDetector.detectChanges();
    }
    ngOnInit() {
        this.setSectionsInSectionItems();
        this.changePeriod(this.periods[0], false);
        this.itemPush();
        this.itemPop();
        this.itemRemove();
        this.sectionPush();
        this.sectionPop();
        this.sectionRemove();
        this.refresh();
    }
    refreshView() {
        this.setSectionsInSectionItems();
        this.changePeriod(this.currentPeriod, false);
    }
    trackByFn(index, item) {
        return index;
    }
    setSectionsInSectionItems() {
        this.sectionItems = new Array();
        this.sections.forEach(section => {
            const perSectionItem = new SectionItem();
            perSectionItem.section = section;
            perSectionItem.minRowHeight = this.minRowHeight;
            this.sectionItems.push(perSectionItem);
        });
    }
    setItemsInSectionItems() {
        const itemMetas = new Array();
        this.sectionItems.forEach(ele => {
            ele.itemMetas = new Array();
            ele.minRowHeight = this.minRowHeight;
            this.items.filter(i => {
                let itemMeta = new ItemMeta();
                if (i.sectionID === ele.section.id) {
                    itemMeta.item = i;
                    if (itemMeta.item.start <= this.end && itemMeta.item.end >= this.start) {
                        itemMeta = this.itemMetaCal(itemMeta);
                        ele.itemMetas.push(itemMeta);
                        itemMetas.push(itemMeta);
                    }
                }
            });
        });
        const sortedItems = itemMetas.reduce((sortItems, itemMeta) => {
            const index = this.sectionItems.findIndex(sectionItem => sectionItem.section.id === itemMeta.item.sectionID);
            if (!sortItems[index]) {
                sortItems[index] = [];
            }
            sortItems[index].push(itemMeta);
            return sortItems;
        }, {});
        this.calCssTop(sortedItems);
    }
    itemMetaCal(itemMeta) {
        const foundStart = moment.max(itemMeta.item.start, this.start);
        const foundEnd = moment.min(itemMeta.item.end, this.end);
        let widthMinuteDiff = Math.abs(foundStart.diff(foundEnd, 'minutes'));
        let leftMinuteDiff = foundStart.diff(this.start, 'minutes');
        if (this.showBusinessDayOnly) {
            widthMinuteDiff -= (this.getNumberOfWeekendDays(moment(foundStart), moment(foundEnd)) * this.currentPeriod.timeFramePeriod);
            leftMinuteDiff -= (this.getNumberOfWeekendDays(moment(this.start), moment(foundStart)) * this.currentPeriod.timeFramePeriod);
        }
        itemMeta.cssLeft = (leftMinuteDiff / this.currentPeriodMinuteDiff) * 100;
        itemMeta.cssWidth = (widthMinuteDiff / this.currentPeriodMinuteDiff) * 100;
        if (itemMeta.item.start >= this.start) {
            itemMeta.isStart = true;
        }
        if (itemMeta.item.end <= this.end) {
            itemMeta.isEnd = true;
        }
        return itemMeta;
    }
    calCssTop(sortedItems) {
        for (const prop of Object.keys(sortedItems)) {
            for (let i = 0; i < sortedItems[prop].length; i++) {
                let elemBottom;
                const elem = sortedItems[prop][i];
                for (let prev = 0; prev < i; prev++) {
                    const prevElem = sortedItems[prop][prev];
                    const prevElemBottom = prevElem.cssTop + this.minRowHeight;
                    elemBottom = elem.cssTop + this.minRowHeight;
                    if (((prevElem.item.start <= elem.item.start && elem.item.start <= prevElem.item.end) ||
                        (prevElem.item.start <= elem.item.end && elem.item.end <= prevElem.item.end) ||
                        (prevElem.item.start >= elem.item.start && elem.item.end >= prevElem.item.end)) && ((prevElem.cssTop <= elem.cssTop && elem.cssTop <= prevElemBottom) ||
                        (prevElem.cssTop <= elemBottom && elemBottom <= prevElemBottom))) {
                        elem.cssTop = prevElemBottom + 1;
                    }
                }
                elemBottom = elem.cssTop + this.minRowHeight + 1;
                if (this.sectionItems[Number(prop)] && elemBottom > this.sectionItems[Number(prop)].minRowHeight) {
                    this.sectionItems[Number(prop)].minRowHeight = elemBottom;
                }
            }
        }
    }
    changePeriod(period, userTrigger = true) {
        this.currentPeriod = period;
        const _start = this.start;
        this.end = moment(_start).add(this.currentPeriod.timeFrameOverall, 'minutes').endOf('day');
        this.currentPeriodMinuteDiff = Math.abs(this.start.diff(this.end, 'minutes'));
        if (userTrigger && this.events.PeriodChange) {
            this.events.PeriodChange(this.start, this.end);
        }
        if (this.showBusinessDayOnly) {
            this.currentPeriodMinuteDiff -=
                (this.getNumberOfWeekendDays(moment(this.start), moment(this.end)) * this.currentPeriod.timeFramePeriod);
        }
        this.header = new Array();
        this.currentPeriod.timeFrameHeaders.forEach((ele, index) => {
            this.header.push(this.getDatesBetweenTwoDates(ele, index));
        });
        this.setItemsInSectionItems();
        this.showCurrentTimeIndicator();
    }
    gotoToday() {
        this.start = moment().startOf('day');
        this.changePeriod(this.currentPeriod);
    }
    nextPeriod() {
        this.start.add(this.currentPeriod.timeFrameOverall, 'minutes');
        this.changePeriod(this.currentPeriod);
    }
    previousPeriod() {
        this.start.subtract(this.currentPeriod.timeFrameOverall, 'minutes');
        this.changePeriod(this.currentPeriod);
    }
    gotoDate(event) {
        this.showGotoModal = false;
        this.start = moment(event).startOf('day');
        this.changePeriod(this.currentPeriod);
    }
    getDatesBetweenTwoDates(format, index) {
        const now = moment(this.start);
        const dates = new Header();
        let prev;
        let colspan = 0;
        while (now.isBefore(this.end) || now.isSame(this.end)) {
            if (!this.showBusinessDayOnly || (now.day() !== 0 && now.day() !== 6)) {
                const headerDetails = new HeaderDetails();
                headerDetails.name = now.locale(this.locale).format(format);
                if (prev && prev !== headerDetails.name) {
                    colspan = 1;
                }
                else {
                    colspan++;
                    dates.headerDetails.pop();
                }
                prev = headerDetails.name;
                headerDetails.colspan = colspan;
                headerDetails.tooltip = this.currentPeriod.timeFrameHeadersTooltip && this.currentPeriod.timeFrameHeadersTooltip[index] ?
                    now.locale(this.locale).format(this.currentPeriod.timeFrameHeadersTooltip[index]) : '';
                dates.headerDetails.push(headerDetails);
            }
            now.add(this.currentPeriod.timeFramePeriod, 'minutes');
        }
        return dates;
    }
    getNumberOfWeekendDays(startDate, endDate) {
        let count = 0;
        while (startDate.isBefore(endDate) || startDate.isSame(endDate)) {
            if ((startDate.day() === 0 || startDate.day() === 6)) {
                count++;
            }
            startDate.add(this.currentPeriod.timeFramePeriod, 'minutes');
        }
        return count;
    }
    drop(event) {
        event.item.data.sectionID = event.container.data.id;
        this.refreshView();
        this.events.ItemDropped(event.item.data);
    }
    itemPush() {
        this.subscription.add(this.service.itemAdd.asObservable().subscribe((item) => {
            this.items.push(item);
            this.refreshView();
        }));
    }
    itemPop() {
        this.subscription.add(this.service.item.asObservable().subscribe(() => {
            this.items.pop();
            this.refreshView();
        }));
    }
    itemRemove() {
        this.subscription.add(this.service.itemId.asObservable().subscribe((itemId) => {
            this.items.splice(this.items.findIndex((item) => {
                return item.id === itemId;
            }), 1);
            this.refreshView();
        }));
    }
    sectionPush() {
        this.subscription.add(this.service.sectionAdd.asObservable().subscribe((section) => {
            this.sections.push(section);
            this.refreshView();
        }));
    }
    sectionPop() {
        this.subscription.add(this.service.section.asObservable().subscribe(() => {
            this.sections.pop();
            this.refreshView();
        }));
    }
    sectionRemove() {
        this.subscription.add(this.service.sectionId.asObservable().subscribe((sectionId) => {
            this.sections.splice(this.sections.findIndex((section) => {
                return section.id === sectionId;
            }), 1);
            this.refreshView();
        }));
    }
    refresh() {
        this.subscription.add(this.service.refreshView.asObservable().subscribe(() => {
            this.refreshView();
        }));
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
};
NgxTimeSchedulerComponent.ɵfac = function NgxTimeSchedulerComponent_Factory(t) { return new (t || NgxTimeSchedulerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(NgxTimeSchedulerService)); };
NgxTimeSchedulerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NgxTimeSchedulerComponent, selectors: [["ngx-ts", "items", "", "periods", "", "sections", ""]], viewQuery: function NgxTimeSchedulerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.SectionTd = _t.first);
    } }, inputs: { currentTimeFormat: "currentTimeFormat", showCurrentTime: "showCurrentTime", showGoto: "showGoto", showToday: "showToday", allowDragging: "allowDragging", locale: "locale", showBusinessDayOnly: "showBusinessDayOnly", headerFormat: "headerFormat", minRowHeight: "minRowHeight", maxHeight: "maxHeight", text: "text", events: "events", start: "start", items: "items", sections: "sections", periods: "periods" }, attrs: _c1, decls: 23, vars: 18, consts: [[1, "time-sch-wrapper"], [1, "time-sch-header-wrapper", "mb-1"], [1, "time-sch-period-container"], ["class", "btn", 3, "ngClass", "title", "click", 4, "ngFor", "ngForOf"], [1, "time-sch-time-container"], ["class", "btn", 3, "click", 4, "ngIf"], ["class", "goto-modal", 4, "ngIf"], [1, "btn", 3, "click"], [1, "text-center", "m-0"], [1, "time-sch-table-wrapper"], [1, "time-sch-table"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "time-sch-content-wrap"], [3, "height", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["cdkDropListGroup", "", 1, "time-sch-section-wrapper"], ["class", "time-sch-section-container", "cdkDropList", "", "cdkDropListSortingDisabled", "", 3, "cdkDropListData", "height", "cdkDropListDropped", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["class", "time-sch-current-time", 3, "title", "visibility", "left", 4, "ngIf"], [1, "btn", 3, "ngClass", "title", "click"], [1, "goto-modal"], ["type", "date", 3, "change"], ["class", "time-sch-section text-center", 3, "rowSpan", 4, "ngIf"], ["class", "text-center", 3, "colSpan", "title", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "time-sch-section", "text-center", 3, "rowSpan"], [1, "text-center", 3, "colSpan", "title"], [1, "time-sch-section", "text-center", 3, "title", "click", "contextmenu"], ["sectionTd", ""], ["cdkDropList", "", "cdkDropListSortingDisabled", "", 1, "time-sch-section-container", 3, "cdkDropListData", "cdkDropListDropped"], ["class", "time-sch-item", "cdkDrag", "", "cdkDragLockAxis", "y", "cdkDragBoundary", ".time-sch-section-wrapper", 3, "cdkDragData", "cdkDragDisabled", "ngClass", "height", "top", "left", "width", "click", "contextmenu", 4, "ngFor", "ngForOf"], ["cdkDrag", "", "cdkDragLockAxis", "y", "cdkDragBoundary", ".time-sch-section-wrapper", 1, "time-sch-item", 3, "cdkDragData", "cdkDragDisabled", "ngClass", "click", "contextmenu"], ["class", "item-drag-placeholder", 3, "height", "left", "width", 4, "cdkDragPlaceholder"], ["class", "time-sch-item-start", 4, "ngIf"], [1, "time-sch-item-content", 3, "title"], ["class", "time-sch-item-end", 4, "ngIf"], [1, "item-drag-placeholder"], [1, "time-sch-item-start"], [1, "time-sch-item-end"], [1, "time-sch-current-time", 3, "title"]], template: function NgxTimeSchedulerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "div", 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵtemplate(3, NgxTimeSchedulerComponent_button_3_Template, 2, 3, "button", 3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "div", 4);
        ɵngcc0.ɵɵtemplate(5, NgxTimeSchedulerComponent_button_5_Template, 2, 1, "button", 5);
        ɵngcc0.ɵɵtemplate(6, NgxTimeSchedulerComponent_div_6_Template, 3, 0, "div", 6);
        ɵngcc0.ɵɵtemplate(7, NgxTimeSchedulerComponent_button_7_Template, 2, 1, "button", 5);
        ɵngcc0.ɵɵelementStart(8, "button", 7);
        ɵngcc0.ɵɵlistener("click", function NgxTimeSchedulerComponent_Template_button_click_8_listener() { return ctx.previousPeriod(); });
        ɵngcc0.ɵɵtext(9);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(10, "button", 7);
        ɵngcc0.ɵɵlistener("click", function NgxTimeSchedulerComponent_Template_button_click_10_listener() { return ctx.nextPeriod(); });
        ɵngcc0.ɵɵtext(11);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "h3", 8);
        ɵngcc0.ɵɵtext(13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(14, "div", 9);
        ɵngcc0.ɵɵelementStart(15, "table", 10);
        ɵngcc0.ɵɵtemplate(16, NgxTimeSchedulerComponent_tr_16_Template, 3, 3, "tr", 11);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(17, "div", 12);
        ɵngcc0.ɵɵelementStart(18, "table", 10);
        ɵngcc0.ɵɵtemplate(19, NgxTimeSchedulerComponent_tr_19_Template, 5, 8, "tr", 13);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(20, "div", 14);
        ɵngcc0.ɵɵtemplate(21, NgxTimeSchedulerComponent_div_21_Template, 2, 4, "div", 15);
        ɵngcc0.ɵɵtemplate(22, NgxTimeSchedulerComponent_div_22_Template, 1, 5, "div", 16);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵstyleProp("height", ctx.maxHeight);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.periods);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showGoto);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showGotoModal);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showToday);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.text.PrevButton);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate(ctx.text.NextButton);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵtextInterpolate1(" ", ctx.start.locale(ctx.locale).format(ctx.headerFormat) + " - " + ctx.end.locale(ctx.locale).format(ctx.headerFormat), " ");
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.header)("ngForTrackBy", ctx.trackByFn);
        ɵngcc0.ɵɵadvance(3);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.sectionItems)("ngForTrackBy", ctx.trackByFn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵstyleProp("left", ctx.SectionLeftMeasure);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.sectionItems)("ngForTrackBy", ctx.trackByFn);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.showCurrentTime);
    } }, directives: [ɵngcc1.NgForOf, ɵngcc1.NgIf, ɵngcc2.CdkDropListGroup, ɵngcc1.NgClass, ɵngcc2.CdkDropList, ɵngcc2.CdkDrag, ɵngcc2.CdkDragPlaceholder], styles: [".d-inline-block[_ngcontent-%COMP%]{display:inline-block!important}.text-center[_ngcontent-%COMP%]{text-align:center!important}.m-0[_ngcontent-%COMP%]{margin:0!important}.mb-1[_ngcontent-%COMP%]{margin-bottom:1rem!important}.btn[_ngcontent-%COMP%]{border:1px solid #e1e1e1;font-weight:600;text-decoration:none;color:#222;height:30px;padding:.5em 1em;cursor:pointer;margin:.2rem;border-radius:4px}.goto-modal[_ngcontent-%COMP%]{position:absolute;top:100%;left:0;height:auto;width:auto;border-radius:4px;background-color:#ddd;padding:5px;text-align:left;z-index:1}.time-sch-wrapper[_ngcontent-%COMP%]{overflow:auto}.time-sch-header-wrapper[_ngcontent-%COMP%], .time-sch-table-wrapper[_ngcontent-%COMP%], .time-sch-wrapper[_ngcontent-%COMP%]{position:relative}.time-sch-header-wrapper[_ngcontent-%COMP%]{padding:.5em;margin-bottom:.5em}.time-sch-table[_ngcontent-%COMP%]{width:100%;table-layout:fixed;border-collapse:collapse;border-spacing:0}.time-sch-period-container[_ngcontent-%COMP%]{float:left;position:relative}.time-sch-time-container[_ngcontent-%COMP%]{float:right;position:relative}.time-sch-wrapper[_ngcontent-%COMP%]   .time-sch-section[_ngcontent-%COMP%]{width:200px}.time-sch-wrapper[_ngcontent-%COMP%]   td[_ngcontent-%COMP%], .time-sch-wrapper[_ngcontent-%COMP%]   th[_ngcontent-%COMP%]{border-width:1px;border-style:solid;border-color:#e1e1e1 #c1c1c1}.time-sch-content-wrap[_ngcontent-%COMP%]{position:relative}.time-sch-section-wrapper[_ngcontent-%COMP%]{position:absolute;top:0;right:0;bottom:0;z-index:1;padding-left:1px;padding-right:1px}.time-sch-section-container[_ngcontent-%COMP%]{position:relative;overflow:hidden}.time-sch-item[_ngcontent-%COMP%]{position:absolute;min-height:1em;clear:both;background-color:#29d;color:#fff;border-radius:2px;cursor:pointer;transition:background-color .1s;border:1px solid #c1c1c1}.time-sch-item-content[_ngcontent-%COMP%]{overflow:hidden;white-space:nowrap;position:relative;z-index:1;padding:4px 0 4px 6px}.time-sch-item-end[_ngcontent-%COMP%], .time-sch-item-start[_ngcontent-%COMP%]{position:absolute;top:2px;bottom:2px}.time-sch-item-start[_ngcontent-%COMP%]{left:1px;border-right:2px dotted #fff}.time-sch-item-end[_ngcontent-%COMP%]{right:1px;border-left:2px dotted #fff}.time-sch-current-time[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;z-index:2;background:0 0;border-left:1px dotted #000}.item-drag-placeholder[_ngcontent-%COMP%]{position:absolute;background:#ccc;border:3px dotted #999;transition:transform 250ms cubic-bezier(0,0,.2,1)}"] });
NgxTimeSchedulerComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgxTimeSchedulerService }
];
__decorate([
    ViewChild('sectionTd'),
    __metadata("design:type", ElementRef),
    __metadata("design:paramtypes", [ElementRef])
], NgxTimeSchedulerComponent.prototype, "SectionTd", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxTimeSchedulerComponent.prototype, "currentTimeFormat", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxTimeSchedulerComponent.prototype, "showCurrentTime", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxTimeSchedulerComponent.prototype, "showGoto", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxTimeSchedulerComponent.prototype, "showToday", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxTimeSchedulerComponent.prototype, "allowDragging", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxTimeSchedulerComponent.prototype, "locale", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxTimeSchedulerComponent.prototype, "showBusinessDayOnly", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxTimeSchedulerComponent.prototype, "headerFormat", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxTimeSchedulerComponent.prototype, "minRowHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NgxTimeSchedulerComponent.prototype, "maxHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxTimeSchedulerComponent.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NgxTimeSchedulerComponent.prototype, "items", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NgxTimeSchedulerComponent.prototype, "sections", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], NgxTimeSchedulerComponent.prototype, "periods", void 0);
__decorate([
    Input(),
    __metadata("design:type", Events)
], NgxTimeSchedulerComponent.prototype, "events", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NgxTimeSchedulerComponent.prototype, "start", void 0);
NgxTimeSchedulerComponent = __decorate([ __metadata("design:paramtypes", [ChangeDetectorRef,
        NgxTimeSchedulerService])
], NgxTimeSchedulerComponent);

let NgxTimeSchedulerModule = class NgxTimeSchedulerModule {
};
NgxTimeSchedulerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: NgxTimeSchedulerModule });
NgxTimeSchedulerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function NgxTimeSchedulerModule_Factory(t) { return new (t || NgxTimeSchedulerModule)(); }, imports: [[
            CommonModule,
            DragDropModule
        ]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxTimeSchedulerService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxTimeSchedulerComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-ts[items][periods][sections]',
                template: "<div class=\"time-sch-wrapper\" [style.height]=\"maxHeight\">\n  <div class=\"time-sch-header-wrapper mb-1\">\n    <div class=\"time-sch-period-container\">\n      <button class=\"btn\"\n              *ngFor=\"let period of periods\"\n              [ngClass]=\"period.classes\"\n              (click)=\"changePeriod(period)\"\n              [title]=\"period.tooltip? period.tooltip : ''\"\n      >\n        {{period.name}}\n      </button>\n    </div>\n\n    <div class=\"time-sch-time-container\">\n      <button class=\"btn\" *ngIf=\"showGoto\" (click)=\"showGotoModal = !showGotoModal\">{{text.GotoButton}}</button>\n      <div class=\"goto-modal\" *ngIf=\"showGotoModal\">\n        <label>\n          <input type=\"date\" (change)=\"gotoDate($event.target.value)\">\n        </label>\n      </div>\n\n      <button class=\"btn\" *ngIf=\"showToday\" (click)=\"gotoToday()\">{{text.TodayButton}}</button>\n      <button class=\"btn\" (click)=\"previousPeriod()\">{{text.PrevButton}}</button>\n      <button class=\"btn\" (click)=\"nextPeriod()\">{{text.NextButton}}</button>\n    </div>\n\n    <h3 class=\"text-center m-0\">\n      {{ start.locale(locale).format(headerFormat) + ' - ' + end.locale(locale).format(headerFormat)}}\n    </h3>\n  </div>\n\n  <div class=\"time-sch-table-wrapper\">\n    <table class=\"time-sch-table\">\n      <tr *ngFor=\"let timeFrameHeader of header; let i = index; trackBy: trackByFn\">\n\n        <td class=\"time-sch-section text-center\" *ngIf=\"i === 0\" [rowSpan]=\"periods.length\">\n          {{text.SectionTitle}}\n        </td>\n\n        <td class=\"text-center\"\n            *ngFor=\"let dateTime of timeFrameHeader.headerDetails; trackBy: trackByFn\"\n            [colSpan]=\"dateTime.colspan\"\n            [title]=\"dateTime.tooltip? dateTime.tooltip : ''\"\n        >\n          {{dateTime.name}}\n        </td>\n\n      </tr>\n    </table>\n\n    <div class=\"time-sch-content-wrap\">\n      <table class=\"time-sch-table\">\n        <tr *ngFor=\"let sectionItem of sectionItems; trackBy: trackByFn\"\n            [style.height]=\"sectionItem.minRowHeight + 'px'\">\n          <td class=\"time-sch-section text-center\" #sectionTd\n              (click)=\"events.SectionClickEvent ? events.SectionClickEvent(sectionItem.section) : false\"\n              (contextmenu)=\"events.SectionContextMenuEvent ? events.SectionContextMenuEvent(sectionItem.section, $event) : false\"\n              [style.cursor]=\"events.SectionClickEvent ? 'pointer' : ''\"\n              [title]=\"sectionItem.section.tooltip? sectionItem.section.tooltip : ''\"\n          >\n            {{sectionItem.section.name}}\n          </td>\n\n          <td *ngFor=\"let td of header[header.length - 1].headerDetails; trackBy: trackByFn\"></td>\n        </tr>\n      </table>\n\n      <div class=\"time-sch-section-wrapper\" [style.left]=\"SectionLeftMeasure\" cdkDropListGroup>\n        <div class=\"time-sch-section-container\"\n             cdkDropList\n             cdkDropListSortingDisabled\n             [cdkDropListData]=\"sectionItem.section\"\n             (cdkDropListDropped)=\"drop($event)\"\n             *ngFor=\"let sectionItem of sectionItems; trackBy: trackByFn\"\n             [style.height]=\"sectionItem.minRowHeight + 'px'\"\n        >\n          <div class=\"time-sch-item\"\n               cdkDrag\n               cdkDragLockAxis=\"y\"\n               cdkDragBoundary=\".time-sch-section-wrapper\"\n               [cdkDragData]=\"itemMeta.item\"\n               [cdkDragDisabled]=\"!allowDragging\"\n               *ngFor=\"let itemMeta of sectionItem.itemMetas\"\n               [ngClass]=\"itemMeta.item.classes\"\n               (click)=\"events.ItemClicked ? events.ItemClicked(itemMeta.item) : false\"\n               (contextmenu)=\"events.ItemContextMenu ? events.ItemContextMenu(itemMeta.item, $event) : false\"\n               [style.height]=\"minRowHeight + 'px'\"\n               [style.top]=\"itemMeta.cssTop + 'px'\"\n               [style.left]=\"itemMeta.cssLeft + '%'\"\n               [style.width]=\"itemMeta.cssWidth + '%'\"\n          >\n            <div class=\"item-drag-placeholder\"\n                 *cdkDragPlaceholder\n                 [style.height]=\"(minRowHeight - 6) + 'px'\"\n                 [style.left]=\"itemMeta.cssLeft + '%'\"\n                 [style.width]=\"'calc('+ itemMeta.cssWidth + '% - 6px)'\"\n            ></div>\n            <div class=\"time-sch-item-start\" *ngIf=\"itemMeta.isStart\"></div>\n            <div class=\"time-sch-item-content\"\n                 [title]=\"itemMeta.item.tooltip? itemMeta.item.tooltip : ''\">\n              {{itemMeta.item.name}}\n            </div>\n            <div class=\"time-sch-item-end\" *ngIf=\"itemMeta.isEnd\"></div>\n          </div>\n        </div>\n\n        <div class=\"time-sch-current-time\"\n             *ngIf=\"showCurrentTime\"\n             [title]=\"currentTimeTitle\"\n             [style.visibility]=\"currentTimeVisibility\"\n             [style.left]=\"currentTimeIndicatorPosition\"\n        ></div>\n      </div>\n\n    </div>\n  </div>\n</div>\n",
                styles: [".d-inline-block{display:inline-block!important}.text-center{text-align:center!important}.m-0{margin:0!important}.mb-1{margin-bottom:1rem!important}.btn{border:1px solid #e1e1e1;font-weight:600;text-decoration:none;color:#222;height:30px;padding:.5em 1em;cursor:pointer;margin:.2rem;border-radius:4px}.goto-modal{position:absolute;top:100%;left:0;height:auto;width:auto;border-radius:4px;background-color:#ddd;padding:5px;text-align:left;z-index:1}.time-sch-wrapper{overflow:auto}.time-sch-header-wrapper,.time-sch-table-wrapper,.time-sch-wrapper{position:relative}.time-sch-header-wrapper{padding:.5em;margin-bottom:.5em}.time-sch-table{width:100%;table-layout:fixed;border-collapse:collapse;border-spacing:0}.time-sch-period-container{float:left;position:relative}.time-sch-time-container{float:right;position:relative}.time-sch-wrapper .time-sch-section{width:200px}.time-sch-wrapper td,.time-sch-wrapper th{border-width:1px;border-style:solid;border-color:#e1e1e1 #c1c1c1}.time-sch-content-wrap{position:relative}.time-sch-section-wrapper{position:absolute;top:0;right:0;bottom:0;z-index:1;padding-left:1px;padding-right:1px}.time-sch-section-container{position:relative;overflow:hidden}.time-sch-item{position:absolute;min-height:1em;clear:both;background-color:#29d;color:#fff;border-radius:2px;cursor:pointer;transition:background-color .1s;border:1px solid #c1c1c1}.time-sch-item-content{overflow:hidden;white-space:nowrap;position:relative;z-index:1;padding:4px 0 4px 6px}.time-sch-item-end,.time-sch-item-start{position:absolute;top:2px;bottom:2px}.time-sch-item-start{left:1px;border-right:2px dotted #fff}.time-sch-item-end{right:1px;border-left:2px dotted #fff}.time-sch-current-time{position:absolute;top:0;bottom:0;z-index:2;background:0 0;border-left:1px dotted #000}.item-drag-placeholder{position:absolute;background:#ccc;border:3px dotted #999;transition:transform 250ms cubic-bezier(0,0,.2,1)}"]
            }]
    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: NgxTimeSchedulerService }]; }, { currentTimeFormat: [{
            type: Input
        }], showCurrentTime: [{
            type: Input
        }], showGoto: [{
            type: Input
        }], showToday: [{
            type: Input
        }], allowDragging: [{
            type: Input
        }], locale: [{
            type: Input
        }], showBusinessDayOnly: [{
            type: Input
        }], headerFormat: [{
            type: Input
        }], minRowHeight: [{
            type: Input
        }], maxHeight: [{
            type: Input
        }], text: [{
            type: Input
        }], events: [{
            type: Input
        }], start: [{
            type: Input
        }], SectionTd: [{
            type: ViewChild,
            args: ['sectionTd']
        }], items: [{
            type: Input
        }], sections: [{
            type: Input
        }], periods: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxTimeSchedulerModule, { declarations: function () { return [NgxTimeSchedulerComponent]; }, imports: function () { return [CommonModule,
        DragDropModule]; }, exports: function () { return [NgxTimeSchedulerComponent]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NgxTimeSchedulerModule, [{
        type: NgModule,
        args: [{
                declarations: [NgxTimeSchedulerComponent],
                imports: [
                    CommonModule,
                    DragDropModule
                ],
                exports: [NgxTimeSchedulerComponent]
            }]
    }], null, null); })();

/*
 * Public API Surface of ngx-time-scheduler
 */

/**
 * Generated bundle index. Do not edit.
 */

export { Events, Header, HeaderDetails, Item, ItemMeta, NgxTimeSchedulerComponent, NgxTimeSchedulerModule, NgxTimeSchedulerService, Period, Section, SectionItem, Text };

//# sourceMappingURL=ngx-time-scheduler.js.map